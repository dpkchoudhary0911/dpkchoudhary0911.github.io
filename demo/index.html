<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Vector Run — Mobile Demo</title>
<style>
:root {
  --bg: #071018;
  --panel: #0f1620;
  --accent: #2fbf9f;
  --accent2: #6b6fff;
  --muted: #9aa9b1;
  --white: #e6eef1;
}
body {
  margin:0;
  font-family: Inter, Arial, Helvetica, sans-serif;
  background: linear-gradient(180deg, var(--bg), #041018);
  color: var(--white);
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 16px;
}
.wrap {
  width: 100%;
  max-width: 960px;
}
header { margin-bottom:12px; text-align:center;}
header h1 { margin:0; font-size:20px;}
header p { margin:4px 0 12px 0; color: var(--muted); font-size:14px; }

.panel {
  background: var(--panel);
  border:1px solid rgba(255,255,255,0.03);
  border-radius: 10px;
  padding:12px;
  margin-bottom:12px;
}

input[type=text], input[type=number] {
  padding:8px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.04);
  background: rgba(0,0,0,0.18);
  color: var(--white);
  width: 100%;
  box-sizing: border-box;
  margin-bottom:6px;
}

button {
  background: linear-gradient(90deg,var(--accent),var(--accent2));
  border:0;
  padding:10px;
  border-radius:8px;
  color:#041018;
  font-weight:700;
  cursor:pointer;
  width:100%;
  margin-top:6px;
}

button.ghost {
  background:transparent;
  border:1px solid rgba(255,255,255,0.04);
  color: var(--accent);
}

.game-area {
  display:flex;
  flex-direction: column;
  align-items:center;
  width:100%;
}

canvas {
  background: #0b0f12;
  border-radius:8px;
  width:100%;
  max-width:720px;
  height: auto;
  touch-action:none;
  display:block;
}

.hud {
  margin-top:12px;
  width:100%;
  display:flex;
  flex-direction: column;
  gap:8px;
}

.hud .box {
  background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.005));
  padding:8px;
  border-radius:8px;
  border:1px solid rgba(255,255,255,0.02);
}

.lane-buttons {
  display:flex;
  gap:8px;
  margin-top:6px;
}

.lane-buttons button {
  flex:1;
  padding:10px;
}

footer {
  margin-top:16px;
  text-align:center;
  color: var(--muted);
  font-size:12px;
}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Vector Run — Mobile Demo</h1>
    <p>Pick your lane each step. Generate seeds, start round, and cash out anytime.</p>
  </header>

  <div class="panel">
    <input id="serverSeed" type="text" placeholder="Server seed (hex)">
    <input id="clientSeed" type="text" placeholder="Client seed">
    <input id="nonce" type="number" value="1" min="0">
    <button id="genSeeds" class="ghost">Generate Seeds</button>
  </div>

  <div class="game-area">
    <canvas id="gameCanvas" width="720" height="360"></canvas>

    <div class="hud">
      <div class="box"><strong>Round:</strong> <span id="roundInfo">Idle</span></div>
      <div class="box"><strong>Step:</strong> <span id="stepInfo">0</span></div>
      <div class="box"><strong>Multiplier:</strong> <span id="multInfo">1.00x</span></div>
      <div class="box">
        <button id="startBtn">Start Round</button>
        <button id="cashBtn" class="ghost" disabled>Cash Out</button>
      </div>
      <div class="box">
        <div class="lane-buttons">
          <button id="lane0">Left</button>
          <button id="lane1">Middle</button>
          <button id="lane2">Right</button>
        </div>
      </div>
      <div class="box"><strong>Seed Preview:</strong><div id="seedPreview" style="word-break:break-word;"></div></div>
      <div class="box"><strong>Last Outcome:</strong> <span id="lastOutcome">—</span></div>
    </div>
  </div>

  <footer>Demo uses SHA-256 via browser crypto API. Server-side authoritative RNG needed for production.</footer>
</div>

<script>
/* ---------------------- Utilities ---------------------- */
function bytesToHex(bytes){ return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join(''); }
async function sha256Bytes(data){ const h = await crypto.subtle.digest('SHA-256', data); return new Uint8Array(h); }
function randHex(len=64){ const a=new Uint8Array(len/2); crypto.getRandomValues(a); return bytesToHex(a); }

/* ---------------------- Deterministic RNG ---------------------- */
class DetermRNG {
  constructor(serverSeed, clientSeed, nonce){
    this.serverSeed=serverSeed||'';
    this.clientSeed=clientSeed||'';
    this.nonce=String(nonce||'0');
    this.counter=0;
    this.buffer=new Uint8Array([]);
    this.bufferIndex=0;
  }
  async refill(){
    const msg=`${this.serverSeed}:${this.clientSeed}:${this.nonce}:${this.counter}`;
    const enc=new TextEncoder().encode(msg);
    const hash=await sha256Bytes(enc);
    const newBuf=new Uint8Array(this.buffer.length+hash.length);
    newBuf.set(this.buffer,0);
    newBuf.set(hash,this.buffer.length);
    this.buffer=newBuf;
    this.counter++;
  }
  async nextByte(){ if(this.bufferIndex>=this.buffer.length) await this.refill(); return this.buffer[this.bufferIndex++]; }
  async nextFloat(){ const b0=await this.nextByte(), b1=await this.nextByte(), b2=await this.nextByte(), b3=await this.nextByte(); return (((b0<<24)|(b1<<16)|(b2<<8)|b3)>>>0)/4294967296; }
}

/* ---------------------- DOM ---------------------- */
const serverSeedEl=document.getElementById('serverSeed');
const clientSeedEl=document.getElementById('clientSeed');
const nonceEl=document.getElementById('nonce');
const genBtn=document.getElementById('genSeeds');
const startBtn=document.getElementById('startBtn');
const cashBtn=document.getElementById('cashBtn');
const laneBtns=[0,1,2].map(i=>document.getElementById('lane'+i));
const roundInfo=document.getElementById('roundInfo');
const stepInfo=document.getElementById('stepInfo');
const multInfo=document.getElementById('multInfo');
const seedPreview=document.getElementById('seedPreview');
const lastOutcome=document.getElementById('lastOutcome');

/* ---------------------- Canvas ---------------------- */
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');
let W=canvas.width,H=canvas.height;
function resizeCanvas(){ const ratio=Math.min(window.innerWidth-32,720); canvas.width=Math.floor(ratio); canvas.height=Math.floor(ratio/2); W=canvas.width; H=canvas.height; draw(); }
window.addEventListener('resize',resizeCanvas);
resizeCanvas();

/* ---------------------- Game State ---------------------- */
let rng=null;
let obstacles=[];
let playing=false;
let step=0;
let chosenLane=null; 
let stepPending=false;
const stepFactor=0.2;
const maxSteps=200;

/* ---------------------- Seed / Obstacles ---------------------- */
genBtn.onclick=()=>{
  serverSeedEl.value=randHex(64);
  clientSeedEl.value=Math.random().toString(36).slice(2,12);
  nonceEl.value=Math.floor(Math.random()*999);
};

async function precomputeObstacles(){
  obstacles=[];
  for(let s=1;s<=maxSteps;s++){
    const f=await rng.nextFloat();
    if(f<0.33){ const b=await rng.nextByte(); obstacles.push({step:s,lane:b%3}); }
    else obstacles.push({step:s,lane:null});
  }
}

/* ---------------------- HUD ---------------------- */
function updateHUD(){
  roundInfo.textContent=playing?'LIVE':'Idle';
  stepInfo.textContent=step;
  multInfo.textContent=(1+step*stepFactor).toFixed(2)+'x';
  seedPreview.textContent=`server: ${serverSeedEl.value}\nclient: ${clientSeedEl.value}\nnonce: ${nonceEl.value}`;
}

/* ---------------------- Game Logic ---------------------- */
async function startRound(){
  if(playing) return;
  rng=new DetermRNG(serverSeedEl.value||'',clientSeedEl.value||'demo',nonceEl.value||'1');
  await rng.refill();
  await precomputeObstacles();
  playing=true; step=0; chosenLane=null; stepPending=true;
  startBtn.disabled=true; cashBtn.disabled=false;
  lastOutcome.textContent='—';
  updateHUD();
  requestAnimationFrame(loop);
}

function cashOut(){
  if(!playing) return;
  playing=false;
  startBtn.disabled=false; cashBtn.disabled=true;
  lastOutcome.textContent=`CASHED ${ (1+step*stepFactor).toFixed(2) }x`;
  draw();
}

function chooseLane(l){
  if(!playing || !stepPending) return;
  chosenLane=l;
  stepPending=false;
}

laneBtns.forEach((btn,i)=>btn.onclick=()=>chooseLane(i));
canvas.addEventListener('touchstart',e=>{
  e.preventDefault();
  if(!playing || !stepPending) return;
  const x=e.touches[0].clientX-canvas.getBoundingClientRect().left;
  const lane=Math.min(2,Math.max(0,Math.floor(x/(canvas.width/3))));
  chooseLane(lane);
});
document.addEventListener('keydown',e=>{
  if(!playing || !stepPending) return;
  if(e.key==='ArrowLeft') chooseLane(Math.max(0,chosenLane===null?1:chosenLane-1));
  if(e.key==='ArrowRight') chooseLane(Math.min(2,chosenLane===null?1:chosenLane+1));
});

/* ---------------------- Main Loop ---------------------- */
function loop(){
  draw();
  if(!playing) return;
  if(!stepPending) {
    const ob=obstacles[step];
    if(ob && ob.lane!==null && ob.lane===chosenLane){
      playing=false;
      lastOutcome.textContent=`BUST at step ${step+1}`;
      startBtn.disabled=false; cashBtn.disabled=true;
      updateHUD();
      return;
    }
    step++; stepPending=true; chosenLane=null; updateHUD();
  }
  requestAnimationFrame(loop);
}

/* ---------------------- Drawing ---------------------- */
function draw(){
  ctx.fillStyle='#041018'; ctx.fillRect(0,0,W,H);
  const laneW=W/3;
  for(let i=0;i<3;i++){
    ctx.fillStyle=(i%2===0)?'#081217':'#071018';
    ctx.fillRect(i*laneW,0,laneW,H);
  }
  // runner
  if(chosenLane!==null) {
    const rx=chosenLane*laneW+laneW/2;
    const ry=H-56;
    ctx.fillStyle=var(--accent);
    ctx.fillRect(rx-26,ry-26,52,52);
  }
}

startBtn.onclick=startRound;
cashBtn.onclick=cashOut;
</script>
</body>
</html>
