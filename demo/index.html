<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vector Run — Mobile-Friendly Demo</title>
<style>
:root{
  --bg:#071017; --panel:#0f1620; --muted:#9fbac2; --accent:#28f0d0; --accent2:#7a5bff;
}
body{
  margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:linear-gradient(180deg,#051015,#071018);
  color:#dff5f1;display:flex;flex-direction:column;align-items:center;padding:16px;
}
.wrap{width:100%;max-width:980px}
h1{margin:0 0 8px 0;font-size:20px;color:var(--accent)}
p.lead{margin:6px 0 18px 0;color:var(--muted)}
.panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.03);padding:12px;border-radius:10px;margin-bottom:12px}
label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
input[type="text"], input[type="number"]{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:rgba(0,0,0,0.25);color:inherit;width:100%}
button{cursor:pointer;padding:10px 12px;border-radius:8px;border:0;background:linear-gradient(90deg,var(--accent),var(--accent2));color:#041219;font-weight:700}
button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--accent)}
#canvasWrap{background:linear-gradient(180deg,#071018,#041018);padding:12px;border-radius:12px;border:1px solid rgba(255,255,255,0.03);width:100%}
canvas{display:block;width:100%;height:auto;border-radius:8px;background:#07131a;touch-action:none;}
.lane-buttons{display:flex;gap:8px;margin-top:8px}
.lane-buttons button{flex:1;padding:10px}
.hud .box{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);margin-bottom:12px}
.muted{color:var(--muted)}
.big{font-size:18px;font-weight:700}
</style>
</head>
<body>
<div class="wrap">
  <h1>Vector Run — Mobile Demo</h1>
  <p class="lead">Pick a lane each step before advancing. Tap lane buttons or the runner, or use ← / → keys. Start round to play.</p>

  <div class="panel">
    <label>Server seed (hex)</label>
    <input id="serverSeed" placeholder="server seed (random hex)"/>
    <label>Client seed</label>
    <input id="clientSeed" placeholder="client seed"/>
    <label>Nonce</label>
    <input id="nonce" type="number" min="0" value="1"/>
    <button id="genSeedsBtn" class="ghost">Generate Seeds</button>
  </div>

  <div class="panel hud">
    <div class="box"><div class="muted">Round</div><div id="roundInfo" class="big">Idle</div></div>
    <div class="box"><div class="muted">Step</div><div id="stepDisplay" class="big">0</div></div>
    <div class="box"><div class="muted">Multiplier</div><div id="multDisplay" class="big">1.00x</div></div>
    <div class="box">
      <button id="startBtn">Start Round</button>
      <button id="cashBtn" class="ghost" disabled>Cash Out</button>
    </div>
  </div>

  <div id="canvasWrap" class="panel">
    <canvas id="gameCanvas" width="720" height="360"></canvas>
    <div class="lane-buttons">
      <button id="lane0">Left</button>
      <button id="lane1">Middle</button>
      <button id="lane2">Right</button>
    </div>
  </div>

</div>

<script>
/* Utilities */
function bytesToHex(bytes){return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join('');}
async function sha256Bytes(data){return new Uint8Array(await crypto.subtle.digest('SHA-256', data));}

/* Deterministic RNG */
class DetermRNG {
  constructor(serverSeed, clientSeed, nonce){
    this.serverSeed=serverSeed||''; this.clientSeed=clientSeed||''; this.nonce=String(nonce||'0'); this.counter=0;
    this.buffer=new Uint8Array([]); this.i=0;
  }
  async refill(){
    const msg=`${this.serverSeed}:${this.clientSeed}:${this.nonce}:${this.counter}`;
    const enc=new TextEncoder().encode(msg);
    const hash=await sha256Bytes(enc);
    const nbuf=new Uint8Array(this.buffer.length+hash.length); nbuf.set(this.buffer); nbuf.set(hash,this.buffer.length);
    this.buffer=nbuf; this.i=0; this.counter++;
  }
  async nextByte(){if(this.i>=this.buffer.length) await this.refill(); return this.buffer[this.i++];}
  async nextFloat(){const b0=await this.nextByte(),b1=await this.nextByte(),b2=await this.nextByte(),b3=await this.nextByte();
    return (((b0<<24)|(b1<<16)|(b2<<8)|b3)>>>0)/4294967296;}
}

/* DOM */
const canvas=document.getElementById('gameCanvas'), ctx=canvas.getContext('2d');
let W=canvas.width,H=canvas.height;
const serverSeedEl=document.getElementById('serverSeed'), clientSeedEl=document.getElementById('clientSeed'), nonceEl=document.getElementById('nonce');
const genBtn=document.getElementById('genSeedsBtn'), startBtn=document.getElementById('startBtn'), cashBtn=document.getElementById('cashBtn');
const roundInfo=document.getElementById('roundInfo'), stepDisplay=document.getElementById('stepDisplay'), multDisplay=document.getElementById('multDisplay');
const laneBtns=[document.getElementById('lane0'),document.getElementById('lane1'),document.getElementById('lane2')];

/* Game State */
let rng=null, obstacles=[], playing=false, step=0, chosenLane=null, pendingLane=false;
let stepInterval=700, stepTimer=null, stepFactor=0.22;
const maxPreview=8;

/* Helpers */
function randHex(len=64){const a=new Uint8Array(len/2);crypto.getRandomValues(a);return bytesToHex(a);}
function updateHUD(){
  stepDisplay.textContent=step; multDisplay.textContent=(1+step*stepFactor).toFixed(2)+'x';
  roundInfo.textContent=playing?'LIVE':'Idle';
}

/* Canvas resize */
function resizeCanvas(){const ratio=Math.min(window.innerWidth-32,900);canvas.width=Math.max(480,Math.floor(ratio));canvas.height=Math.floor(canvas.width*0.5); W=canvas.width; H=canvas.height; draw();}
window.addEventListener('resize',resizeCanvas); resizeCanvas();

/* RNG & obstacles */
async function generateObstacles(maxSteps=200){
  obstacles=[]; for(let s=1;s<=maxSteps;s++){
    const f=await rng.nextFloat(); const p=0.33;
    if(f<p){const b=await rng.nextByte(); obstacles.push({step:s,lane:b%3});}else{obstacles.push({step:s,lane:null});}
  }
}

/* Lane selection */
function pickLane(l){chosenLane=l; pendingLane=false; draw();}

/* Event wiring */
genBtn.onclick=()=>{serverSeedEl.value=randHex(64);clientSeedEl.value=Math.random().toString(36).slice(2,12);nonceEl.value=Math.floor(Math.random()*1000);}
laneBtns.forEach((btn,i)=>btn.onclick=()=>pickLane(i));
canvas.addEventListener('click',()=>{chosenLane=(chosenLane+1)%3; pendingLane=false; draw();});
document.addEventListener('keydown',e=>{if(e.key==='ArrowLeft') pickLane(Math.max(0,(chosenLane||1)-1)); if(e.key==='ArrowRight') pickLane(Math.min(2,(chosenLane||1)+1));});

/* Start Round */
startBtn.onclick=async()=>{
  if(playing) return;
  rng=new DetermRNG(serverSeedEl.value,clientSeedEl.value,nonceEl.value); await rng.refill();
  await generateObstacles(200);
  playing=true; step=0; chosenLane=null; pendingLane=true; updateHUD(); startBtn.disabled=true; cashBtn.disabled=false; draw();
  nextStep();
};

/* Cash Out */
cashBtn.onclick=()=>{if(!playing) return; playing=false; clearTimeout(stepTimer); startBtn.disabled=false; cashBtn.disabled=true; updateHUD(); draw();};

/* Step logic */
function nextStep(){
  if(!playing) return;
  pendingLane=true; draw();
  stepTimer=setTimeout(()=>{
    if(chosenLane===null) {nextStep(); return;} // wait for lane pick
    step++;
    const ob=obstacles[step-1];
    if(ob && ob.lane===chosenLane){playing=false; clearTimeout(stepTimer); startBtn.disabled=false; cashBtn.disabled=true; roundInfo.textContent=`BUST @ ${step}`; draw(); return;}
    nextStep();
    updateHUD();
  },stepInterval);
}

/* Draw */
function draw(){
  ctx.fillStyle='#041018'; ctx.fillRect(0,0,W,H);
  const laneW=W/3;
  for(let i=0;i<3;i++){ctx.fillStyle=(i%2===0?'#061826':'#051720'); ctx.fillRect(i*laneW,0,laneW,H);}
  // runner
  const rx=chosenLane!==null?chosenLane*laneW+laneW/2:laneW/2; const ry=H-46;
  ctx.fillStyle='#28f0d0'; ctx.beginPath(); ctx.roundRect(rx-22,ry-34,44,44,8); ctx.fill();
  ctx.fillStyle='#041217'; ctx.font='700 18px Inter'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(String((chosenLane!==null?chosenLane:1)+1),rx,ry-12);
  // obstacles preview
  for(let ahead=0; ahead<maxPreview; ahead++){
    const s=step+1+ahead; if(s>obstacles.length) break;
    const ob=obstacles[s-1]; if(!ob || ob.lane===null) continue;
    const x=ob.lane*laneW+laneW/2; const y=30+(ahead/maxPreview)*(H-140); const w=44-ahead*3;
    ctx.fillStyle=(ahead===0?'#ff6b6b':'#7c3cff'); ctx.beginPath(); ctx.roundRect(x-w/2,y,w,16,6); ctx.fill();
  }
}

/* polyfill roundRect */
if(!CanvasRenderingContext2D.prototype.roundRect){CanvasRenderingContext2D.prototype.roundRect=function(x,y,w,h,r){this.beginPath();this.moveTo(x+r,y);this.arcTo(x+w,y,x+w,y+h,r);this.arcTo(x+w,y+h,x,y+h,r);this.arcTo(x,y+h,x,y,r);this.arcTo(x,y,x+w,y,r);this.closePath();};}

</script>
</body>
</html>
