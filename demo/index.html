<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vector Run — Step-by-Step Demo</title>
<style>
  :root{
    --bg:#071018; --panel:#0f1620; --muted:#9fbac2; --accent:#28f0d0; --accent2:#7a5bff;
  }
  html, body{
    margin:0; padding:0; font-family:Inter,Arial,sans-serif;
    background: linear-gradient(180deg,#051015,#071018);
    color:#dff5f1; -webkit-font-smoothing:antialiased;
    -webkit-touch-callout:none; -webkit-user-select:none; user-select:none;
  }
  .wrap{max-width:980px;margin:0 auto;padding:18px;}
  h1{margin:0 0 8px 0;font-size:20px;color:var(--accent);}
  .panel{background:var(--panel);padding:12px;border-radius:10px;margin-bottom:12px;}
  input, button{border-radius:8px;padding:8px;font-size:14px;}
  button{cursor:pointer;}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.2);color:var(--accent);}
  .game-area{display:flex;flex-wrap:wrap;gap:12px;}
  #canvasWrap{flex:1; background: #041018; border-radius:10px; position:relative;}
  canvas{display:block; width:100%; height:auto;}
  .hud{width:300px;}
  .hud .box{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;margin-bottom:12px;}
  .lane-buttons{display:flex;gap:6px;margin-top:8px;}
  .lane-buttons button{flex:1;padding:10px;}
  .muted{color:var(--muted);}
  .big{font-weight:700;font-size:18px;}
  @media(max-width:860px){ .hud{width:100%;} .game-area{flex-direction:column;} }
  .mult-bar{height:12px;background:#28f0d0;border-radius:6px;margin-top:6px;}
</style>
</head>
<body>
<div class="wrap">
  <h1>Vector Run — Step-by-Step Demo</h1>

  <div class="panel">
    <label>Server seed (hex)</label>
    <input id="serverSeed" type="text" placeholder="server seed (random hex)">
    <label>Client seed</label>
    <input id="clientSeed" type="text" placeholder="client seed">
    <label>Nonce</label>
    <input id="nonce" type="number" min="0" value="1">
    <div style="margin-top:8px;">
      <button id="genSeedsBtn" class="ghost">Generate Seeds</button>
      <button id="startBtn">Start Round</button>
      <button id="cashBtn" class="ghost" disabled>Cash Out</button>
    </div>
  </div>

  <div class="game-area">
    <div id="canvasWrap">
      <canvas id="gameCanvas" width="720" height="360"></canvas>
    </div>
    <div class="hud">
      <div class="box">
        <div class="muted">Round</div>
        <div id="roundInfo" class="big">Idle</div>
      </div>
      <div class="box">
        <div class="muted">Step</div>
        <div id="stepDisplay" class="big">0</div>
      </div>
      <div class="box">
        <div class="muted">Multiplier</div>
        <div id="multDisplay" class="big">1.00x</div>
        <div class="mult-bar" id="multBar"></div>
      </div>
      <div class="box">
        <div class="muted">Lane Selection</div>
        <div class="lane-buttons">
          <button id="lane0">Left</button>
          <button id="lane1">Middle</button>
          <button id="lane2">Right</button>
        </div>
      </div>
      <div class="box">
        <div class="muted">Upcoming Obstacles</div>
        <div id="obstaclePreview" class="muted" style="word-break:break-all"></div>
      </div>
    </div>
  </div>
</div>

<script>
/* --- Utilities --- */
function bytesToHex(bytes){
  return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join('');
}
async function sha256Bytes(data){
  const h = await crypto.subtle.digest('SHA-256', data);
  return new Uint8Array(h);
}
function randHex(len=64){
  const a = new Uint8Array(len/2);
  crypto.getRandomValues(a);
  return bytesToHex(a);
}

/* --- DetermRNG --- */
class DetermRNG {
  constructor(serverSeed, clientSeed, nonce){
    this.serverSeed = serverSeed; this.clientSeed = clientSeed; this.nonce = String(nonce);
    this.counter = 0; this.buf = new Uint8Array([]); this.i = 0;
  }
  async refill(){
    const msg = `${this.serverSeed}:${this.clientSeed}:${this.nonce}:${this.counter}`;
    const hash = await sha256Bytes(new TextEncoder().encode(msg));
    const nbuf = new Uint8Array(this.buf.length + hash.length);
    nbuf.set(this.buf); nbuf.set(hash, this.buf.length);
    this.buf = nbuf; this.counter++;
  }
  async nextByte(){ if(this.i>=this.buf.length) await this.refill(); return this.buf[this.i++]; }
  async nextFloat(){ return ((await this.nextByte())<<24 | (await this.nextByte())<<16 | (await this.nextByte())<<8 | (await this.nextByte()))>>>0 / 4294967296; }
}

/* --- DOM --- */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const serverSeedEl = document.getElementById("serverSeed");
const clientSeedEl = document.getElementById("clientSeed");
const nonceEl = document.getElementById("nonce");
const genBtn = document.getElementById("genSeedsBtn");
const startBtn = document.getElementById("startBtn");
const cashBtn = document.getElementById("cashBtn");
const roundInfo = document.getElementById("roundInfo");
const stepDisplay = document.getElementById("stepDisplay");
const multDisplay = document.getElementById("multDisplay");
const multBar = document.getElementById("multBar");
const laneBtns = [0,1,2].map(i=>document.getElementById(`lane${i}`));
const obstaclePreviewEl = document.getElementById("obstaclePreview");

/* --- Game State --- */
let rng = null, step=0, chosenLane=null;
let obstacles=[], playing=false, stepReady=false;
const stepFactor=0.22;
const stepHeight = canvas.height / 8; // for animation
let currentObstacles = [];

/* --- Helpers --- */
function updateHUD(){
  roundInfo.textContent = playing?'LIVE':'Idle';
  stepDisplay.textContent = step;
  const mult = 1 + step*stepFactor;
  multDisplay.textContent = mult.toFixed(2)+'x';
  multBar.style.width = Math.min(mult/10,1)*100+'%';
  obstaclePreviewEl.textContent = obstacles.slice(step,step+5).map(o=>o.lane===null?'—':`Lane ${o.lane+1}`).join(', ');
}

/* --- Generate Obstacles --- */
async function generateObstacles(maxSteps=50){
  obstacles = [];
  for(let s=0;s<maxSteps;s++){
    const f = await rng.nextFloat();
    if(f<0.33){
      const b = await rng.nextByte();
      obstacles.push({step:s,lane:b%3});
    } else obstacles.push({step:s,lane:null});
  }
}

/* --- Lane selection --- */
function selectLane(l){
  if(!playing) return;
  chosenLane = l; stepReady = true;
}

/* --- Event Listeners --- */
genBtn.onclick = ()=>{
  serverSeedEl.value = randHex(64);
  clientSeedEl.value = Math.random().toString(36).slice(2,12);
  nonceEl.value = Math.floor(Math.random()*999);
};
laneBtns.forEach((btn,i)=>btn.onclick=()=>selectLane(i));
canvas.addEventListener("touchstart", ev=>{
  const rect = canvas.getBoundingClientRect();
  const x = ev.touches[0].clientX - rect.left;
  selectLane(Math.floor(3*x/canvas.width));
});

/* --- Start Round --- */
startBtn.onclick = async ()=>{
  if(playing) return;
  rng = new DetermRNG(serverSeedEl.value||'', clientSeedEl.value||'demo', nonceEl.value||'1');
  await rng.refill();
  await generateObstacles(50);
  step=0; playing=true; chosenLane=null; stepReady=false;
  startBtn.disabled=true; cashBtn.disabled=false;
  updateHUD();
  requestAnimationFrame(gameLoop);
};

/* --- Cash Out --- */
cashBtn.onclick = ()=>{
  if(!playing) return;
  playing=false;
  startBtn.disabled=false; cashBtn.disabled=true;
  roundInfo.textContent='CASHED';
};

/* --- Game Loop --- */
let lastTime=0;
function gameLoop(time){
  if(!lastTime) lastTime=time;
  const dt = time-lastTime; lastTime=time;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // draw lanes
  const laneW = canvas.width/3;
  for(let i=0;i<3;i++){
    ctx.fillStyle=i%2===0?'#061826':'#051720';
    ctx.fillRect(i*laneW,0,laneW,canvas.height);
  }

  // draw runner
  if(chosenLane!==null){
    ctx.fillStyle='#28f0d0';
    ctx.fillRect(chosenLane*laneW+laneW/2-20,canvas.height-60,40,40);
  }

  // obstacle animation
  currentObstacles.forEach(o=>{
    o.y += dt*0.3;
    ctx.fillStyle=o.lane===null?'':'#ff6b6b';
    if(o.lane!==null) ctx.fillRect(o.lane*laneW+laneW/2-22,o.y,44,16);
  });

  if(playing && step<obstacles.length){
    if(stepReady){
      const ob = obstacles[step];
      currentObstacles.push({lane:ob.lane,y:0});
      // check collision immediately
      if(ob.lane!==null && ob.lane===chosenLane){
        playing=false;
        roundInfo.textContent=`BUST @ Step ${step+1}`;
        startBtn.disabled=false; cashBtn.disabled=true;
      } else {
        step++; chosenLane=null; stepReady=false;
      }
      updateHUD();
    }
    if(playing) requestAnimationFrame(gameLoop);
  }
}

</script>
</body>
</html>
