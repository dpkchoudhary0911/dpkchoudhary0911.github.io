<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Vector Run — Animated Demo</title>
<style>
body{margin:0;font-family:sans-serif;background:#071018;color:#fff;display:flex;flex-direction:column;align-items:center;padding:8px;}
button,input{padding:8px;margin:4px;border-radius:6px;border:none;}
button{background:#2fbf9f;color:#041018;font-weight:700;}
button.ghost{background:none;border:1px solid #2fbf9f;color:#2fbf9f;}
#canvasWrap{width:100%;max-width:720px;touch-action:none;}
canvas{width:100%;height:auto;background:#0b0f12;display:block;}
.hud{width:100%;max-width:720px;display:flex;flex-wrap:wrap;gap:8px;margin-top:8px;}
.hud div{flex:1;background:#0f1620;padding:6px;border-radius:6px;text-align:center;}
.lane-buttons{display:flex;gap:4px;}
.lane-buttons button{flex:1;}
.multBar{height:10px;background:#222;border-radius:5px;overflow:hidden;margin-top:4px;}
.multFill{height:100%;background:#2fbf9f;width:0%;}
</style>
</head>
<body>

<div>
  <input id="serverSeed" placeholder="Server Seed (hex)">
  <input id="clientSeed" placeholder="Client Seed">
  <input id="nonce" type="number" value="1" min="0">
  <button id="genSeeds" class="ghost">Generate Seeds</button>
</div>

<div id="canvasWrap"><canvas id="gameCanvas" width="720" height="360"></canvas></div>

<div class="hud">
  <div>Round: <span id="roundInfo">Idle</span></div>
  <div>Step: <span id="stepInfo">0</span></div>
  <div>Multiplier: <span id="multInfo">1.00x<div class="multBar"><div class="multFill" id="multFill"></div></div></span></div>
</div>

<div class="hud">
  <button id="startBtn">Start Round</button>
  <button id="cashBtn" class="ghost" disabled>Cash Out</button>
</div>

<div class="hud lane-buttons">
  <button id="lane0">Left</button>
  <button id="lane1">Middle</button>
  <button id="lane2">Right</button>
</div>

<div class="hud">
  <div>Seed Preview:<div id="seedPreview" style="word-break:break-word;"></div></div>
  <div>Last Outcome: <span id="lastOutcome">—</span></div>
</div>

<script>
/* ----------------- Utilities ----------------- */
function bytesToHex(bytes){return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join('');}
async function sha256Bytes(data){return new Uint8Array(await crypto.subtle.digest('SHA-256',data));}
function randHex(len=64){const a=new Uint8Array(len/2);crypto.getRandomValues(a);return bytesToHex(a);}

/* ----------------- Determ RNG ----------------- */
class DetermRNG{
  constructor(serverSeed, clientSeed, nonce){this.s=serverSeed||'';this.c=clientSeed||'';this.n=String(nonce||'0');this.counter=0;this.buf=new Uint8Array([]);this.idx=0;}
  async refill(){const msg=`${this.s}:${this.c}:${this.n}:${this.counter}`;const enc=new TextEncoder().encode(msg);const h=await sha256Bytes(enc);const b=new Uint8Array(this.buf.length+h.length);b.set(this.buf,0);b.set(h,this.buf.length);this.buf=b;this.idx=0;this.counter++;}
  async nextByte(){if(this.idx>=this.buf.length) await this.refill();return this.buf[this.idx++];}
  async nextFloat(){const b0=await this.nextByte(),b1=await this.nextByte(),b2=await this.nextByte(),b3=await this.nextByte();return (((b0<<24)|(b1<<16)|(b2<<8)|b3)>>>0)/4294967296;}
}

/* ----------------- DOM ----------------- */
const serverSeedEl=document.getElementById('serverSeed');
const clientSeedEl=document.getElementById('clientSeed');
const nonceEl=document.getElementById('nonce');
const genBtn=document.getElementById('genSeeds');
const startBtn=document.getElementById('startBtn');
const cashBtn=document.getElementById('cashBtn');
const laneBtns=[0,1,2].map(i=>document.getElementById('lane'+i));
const roundInfo=document.getElementById('roundInfo');
const stepInfo=document.getElementById('stepInfo');
const multInfo=document.getElementById('multInfo');
const multFill=document.getElementById('multFill');
const seedPreview=document.getElementById('seedPreview');
const lastOutcome=document.getElementById('lastOutcome');
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');

/* ----------------- Game State ----------------- */
let rng=null, obstacles=[], playing=false, step=0, runnerLane=1, targetLane=1, stepPending=true;
const maxSteps=50, stepFactor=0.2;
let animObstacles=[], crashTimer=0;

/* ----------------- Generate Seeds ----------------- */
genBtn.onclick=()=>{serverSeedEl.value=randHex(64);clientSeedEl.value=Math.random().toString(36).slice(2,12);nonceEl.value=Math.floor(Math.random()*999);updateHUD();};

/* ----------------- Lane selection ----------------- */
laneBtns.forEach((b,i)=>b.onclick=()=>{if(playing && stepPending){targetLane=i;stepPending=false;}});
canvas.addEventListener('touchstart',e=>{if(playing && stepPending){const x=e.touches[0].clientX-canvas.getBoundingClientRect().left;targetLane=Math.min(2,Math.floor(x/(canvas.width/3)));stepPending=false;}});

/* ----------------- Start Round ----------------- */
startBtn.onclick=async()=>{
  rng=new DetermRNG(serverSeedEl.value||'',clientSeedEl.value||'demo',nonceEl.value||'1');
  await rng.refill();
  obstacles=[];
  for(let s=0;s<maxSteps;s++){const f=await rng.nextFloat();obstacles.push(f<0.33?(await rng.nextByte())%3:null);}
  playing=true; step=0; runnerLane=1; targetLane=1; stepPending=true; animObstacles=[]; crashTimer=0;
  startBtn.disabled=true; cashBtn.disabled=false; lastOutcome.textContent='—'; updateHUD();
  requestAnimationFrame(loop);
};

/* ----------------- Cash Out ----------------- */
cashBtn.onclick=()=>{if(!playing)return;playing=false;startBtn.disabled=false;cashBtn.disabled=true;lastOutcome.textContent=`CASHED ${(1+step*stepFactor).toFixed(2)}x`;updateHUD();draw();};

/* ----------------- HUD ----------------- */
function updateHUD(){roundInfo.textContent=playing?'LIVE':'Idle';stepInfo.textContent=step;multInfo.textContent=(1+step*stepFactor).toFixed(2)+'x';multFill.style.width=Math.min(100,(step/maxSteps*100))+'%';seedPreview.textContent=`server:${serverSeedEl.value}\nclient:${clientSeedEl.value}\nnonce:${nonceEl.value}`;}

/* ----------------- Loop ----------------- */
let runnerX=runnerLane*canvas.width/3+canvas.width/6;
function loop(){
  draw();
  if(!playing) return;

  // smooth lane movement
  const targetX=targetLane*canvas.width/3+canvas.width/6;
  runnerX+=Math.sign(targetX-runnerX)*Math.min(Math.abs(targetX-runnerX),6);

  if(!stepPending && Math.abs(runnerX-targetX)<2){
    // next step
    animObstacles.push({lane:obstacles[step], y:0});
    step++; stepPending=true; targetLane=runnerLane;
  }

  animObstacles.forEach(o=>o.y+=4);
  animObstacles.forEach(o=>{
    if(o.lane!==null && o.y>canvas.height-56 && Math.abs(runnerX-(o.lane*canvas.width/3+canvas.width/6))<30){
      playing=false; crashTimer=20; lastOutcome.textContent=`BUST at step ${step}`;startBtn.disabled=false;cashBtn.disabled=true;
    }
  });

  animObstacles=animObstacles.filter(o=>o.y<canvas.height);
  updateHUD();
  requestAnimationFrame(loop);
}

/* ----------------- Draw ----------------- */
function draw(){
  ctx.save();
  // crash shake effect
  if(crashTimer>0){ctx.translate(Math.random()*8-4,0); crashTimer--;}
  ctx.fillStyle=crashTimer>0?'#440000':'#041018'; ctx.fillRect(0,0,canvas.width,canvas.height);
  const laneW=canvas.width/3;
  for(let i=0;i<3;i++){ctx.fillStyle=i%2===0?'#081217':'#071018'; ctx.fillRect(i*laneW,0,laneW,canvas.height);}
  // runner
  ctx.fillStyle='#2fbf9f';
  ctx.fillRect(runnerX-26,canvas.height-56,52,52);
  // obstacles
  animObstacles.forEach(o=>{if(o.lane!==null){ctx.fillStyle='#ff4c4c';ctx.fillRect(o.lane*laneW+laneW/2-22,o.y,44,16);}});
  ctx.restore();
}

</script>
</body>
</html>
