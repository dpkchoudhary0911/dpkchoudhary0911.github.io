<script>
/* ===========================
   Vector Run â€” Full Fixed Demo
   Async RNG, instant first obstacle
   =========================== */

/* ---------- Utilities ---------- */
function bytesToHex(bytes) {
  return Array.from(bytes).map(b => b.toString(16).padStart(2,'0')).join('');
}

async function sha256Bytes(data) {
  const h = await crypto.subtle.digest('SHA-256', data);
  return new Uint8Array(h);
}

function randHex(len=64) {
  const a = new Uint8Array(len/2);
  crypto.getRandomValues(a);
  return bytesToHex(a);
}

/* ---------- DetermRNG ---------- */
class DetermRNG {
  constructor(serverSeed, clientSeed, nonce){
    this.serverSeed = serverSeed;
    this.clientSeed = clientSeed;
    this.nonce = String(nonce);
    this.counter = 0;
    this.buf = new Uint8Array([]);
    this.i = 0;
  }

  async refill(){
    const msg = `${this.serverSeed}:${this.clientSeed}:${this.nonce}:${this.counter}`;
    const enc = new TextEncoder().encode(msg);
    const hash = await sha256Bytes(enc);
    const nbuf = new Uint8Array(this.buf.length + hash.length);
    nbuf.set(this.buf);
    nbuf.set(hash, this.buf.length);
    this.buf = nbuf;
    this.counter++;
  }

  async nextByte(){
    if(this.i >= this.buf.length) await this.refill();
    return this.buf[this.i++];
  }

  async nextFloat(){
    const b0 = await this.nextByte();
    const b1 = await this.nextByte();
    const b2 = await this.nextByte();
    const b3 = await this.nextByte();
    const int = ((b0<<24)|(b1<<16)|(b2<<8)|b3)>>>0;
    return int / 4294967296;
  }
}

/* ---------- DOM Elements ---------- */
const serverSeedEl = document.getElementById("serverSeed");
const clientSeedEl = document.getElementById("clientSeed");
const nonceEl = document.getElementById("nonce");
const genBtn = document.getElementById("genBtn");
const startBtn = document.getElementById("start");
const cashBtn = document.getElementById("cash");
const roundStateEl = document.getElementById("roundState");
const stepEl = document.getElementById("step");
const multEl = document.getElementById("mult");
const seedPreviewEl = document.getElementById("seedPreview");

/* ---------- Seed Generator ---------- */
genBtn.onclick = ()=>{
  serverSeedEl.value = randHex(64);
  clientSeedEl.value = Math.random().toString(36).slice(2,12);
  nonceEl.value = Math.floor(Math.random()*999);
};

/* ---------- Canvas ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

function resizeCanvas(){
  const ratio = Math.min(window.innerWidth-80, 900);
  canvas.width = Math.max(480, Math.floor(ratio));
  canvas.height = Math.floor(canvas.width * 0.5);
  W = canvas.width;
  H = canvas.height;
  draw();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

/* ---------- Game State ---------- */
let rng = null;
let obstacles = [];
let playing = false;
let step = 0;
let lane = 1;

const stepFactor = 0.20;
const obstacleProbability = 0.32;
const stepInterval = 700;

let lastTime = 0;
let accumulator = 0;

/* ---------- Precompute Obstacles ---------- */
async function precomputeObstacles(max=400){
  obstacles = [];
  for(let s=0; s<max; s++){
    const f = await rng.nextFloat();
    if(f < obstacleProbability){
      const b = await rng.nextByte();
      obstacles.push({step: s, lane: b % 3});
    } else {
      obstacles.push({step: s, lane: null});
    }
  }
}

/* ---------- HUD ---------- */
function updateHUD(){
  stepEl.textContent = step;
  multEl.textContent = (1 + step * stepFactor).toFixed(2) + "x";
  seedPreviewEl.textContent =
    `server: ${serverSeedEl.value}
client: ${clientSeedEl.value}
nonce: ${nonceEl.value}`;
}

/* ---------- Game Logic ---------- */
function doLogicalStep(){
  const ob = obstacles[step];
  if(ob && ob.lane !== null && ob.lane === lane){
    playing = false;
    roundStateEl.textContent = `BUST @ ${step+1}`;
    cashBtn.disabled = true;
    startBtn.disabled = false;
    return;
  }
  step++;
  updateHUD();
}

function loop(now){
  if(!playing){
    draw();
    return;
  }
  if(!lastTime) lastTime = now;

  const dt = now - lastTime;
  lastTime = now;
  accumulator += dt;

  while(accumulator >= stepInterval){
    accumulator -= stepInterval;
    doLogicalStep();
    if(!playing) break;
  }

  draw();
  if(playing) requestAnimationFrame(loop);
}

/* ---------- Start Button ---------- */
startBtn.onclick = async ()=>{
  if(playing) return;

  const s = serverSeedEl.value.trim();
  const c = clientSeedEl.value.trim() || "demo";
  const n = (nonceEl.value || "1").toString();

  if(!s){
    alert("Please enter a valid server seed!");
    return;
  }

  roundStateEl.textContent = "LOADING...";
  startBtn.disabled = true;

  rng = new DetermRNG(s,c,n);
  await rng.refill();
  await precomputeObstacles();

  // Start game instantly
  playing = true;
  step = 0;
  lane = 1;
  accumulator = 0;
  lastTime = performance.now();

  roundStateEl.textContent = "LIVE";
  cashBtn.disabled = false;
  updateHUD();
  draw(); // draw first step immediately

  requestAnimationFrame(loop);
};

/* ---------- Cash Out ---------- */
cashBtn.onclick = ()=>{
  if(!playing) return;
  playing = false;
  startBtn.disabled = false;
  cashBtn.disabled = true;

  const m = 1 + step * stepFactor;
  roundStateEl.textContent = `CASHED ${m.toFixed(2)}x`;
};

/* ---------- Inputs ---------- */
document.addEventListener("keydown", e=>{
  if(e.key === "ArrowLeft") lane = Math.max(0, lane-1);
  if(e.key === "ArrowRight") lane = Math.min(2, lane+1);
});
document.getElementById("laneL").onclick = ()=> lane=0;
document.getElementById("laneM").onclick = ()=> lane=1;
document.getElementById("laneR").onclick = ()=> lane=2;

canvas.addEventListener("touchstart", ev=>{
  ev.preventDefault();
  const x = ev.touches[0].clientX - canvas.getBoundingClientRect().left;
  const part = canvas.width / 3;
  lane = Math.min(2, Math.max(0, Math.floor(x / part)));
});

/* ---------- Drawing ---------- */
function roundRectFill(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.fill();
}

function draw(){
  ctx.fillStyle = "#061015";
  ctx.fillRect(0,0,W,H);

  const lw = W/3;
  for(let i=0;i<3;i++){
    ctx.fillStyle = (i%2===0) ? "#081217" : "#071018";
    ctx.fillRect(i*lw,0,lw,H);
  }

  const preview = 8;
  for(let i=1;i<=preview;i++){
    const idx = step+i-1;
    const ob = obstacles[idx];
    if(!ob || ob.lane===null) continue;

    const frac = i/(preview+1);
    const y = 30 + frac*(H-120);
    const cx = ob.lane*lw + lw/2;
    const w = 48 - i*3;

    ctx.fillStyle = (i===1) ? "#ff6b6b" : "#7c3cff";
    roundRectFill(ctx, cx-w/2, y, w, 16, 6);
  }

  const rx = lane*lw + lw/2;
  const ry = H - 56;

  ctx.fillStyle = "#2fbf9f";
  roundRectFill(ctx, rx-26, ry-36, 52, 52, 8);

  ctx.fillStyle = "#041018";
  ctx.font = "700 18px Inter";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText((lane+1), rx, ry-12);
}

/* ---------- Init ---------- */
draw();
updateHUD();
</script>
