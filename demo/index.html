<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Vector Run Mobile Demo</title>
<style>
  body{margin:0;font-family:sans-serif;background:#071017;color:#dff5f1;display:flex;flex-direction:column;align-items:center;padding:16px;}
  .panel{background:rgba(255,255,255,0.02);padding:12px;border-radius:10px;margin-bottom:12px;}
  button{padding:10px 12px;margin:4px;border:none;border-radius:8px;background:#28f0d0;color:#041218;font-weight:700;flex:1;}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.1);color:#28f0d0;}
  canvas{width:100%;max-width:720px;border-radius:8px;touch-action:none;}
</style>
</head>
<body>

<div class="panel">
  <input id="serverSeed" placeholder="Server seed (hex)" style="width:100%;margin-bottom:4px;">
  <input id="clientSeed" placeholder="Client seed" style="width:100%;margin-bottom:4px;">
  <input id="nonce" type="number" min="0" value="1" style="width:100%;margin-bottom:4px;">
  <div style="display:flex;gap:4px;">
    <button id="genSeedsBtn" class="ghost">Generate</button>
    <button id="startBtn">Start</button>
    <button id="cashBtn" class="ghost" disabled>Cash Out</button>
  </div>
</div>

<canvas id="gameCanvas" width="720" height="360"></canvas>

<div class="panel" style="display:flex;gap:4px;">
  <button id="lane0">Left</button>
  <button id="lane1">Middle</button>
  <button id="lane2">Right</button>
</div>

<div class="panel">
  <div>Step: <span id="stepDisplay">0</span></div>
  <div>Multiplier: <span id="multDisplay">1.00x</span></div>
  <div id="lastOutcome">—</div>
</div>

<script>
/* -----------------------------
   Deterministic RNG & Helpers
----------------------------- */
async function sha256Bytes(data){ return new Uint8Array(await crypto.subtle.digest('SHA-256',data)); }
function bytesToHex(bytes){ return Array.from(bytes).map(b=>b.toString(16).padStart(2,'0')).join(''); }
function randHex(len=64){ const a=new Uint8Array(len/2); crypto.getRandomValues(a); return bytesToHex(a); }

class DetermRNG{
  constructor(server,client,nonce){ this.server=server; this.client=client; this.nonce=String(nonce); this.counter=0; this.buf=new Uint8Array([]); this.i=0;}
  async refill(){ const msg=`${this.server}:${this.client}:${this.nonce}:${this.counter++}`; const enc=new TextEncoder().encode(msg); const h=await sha256Bytes(enc); const newBuf=new Uint8Array(this.buf.length+h.length); newBuf.set(this.buf); newBuf.set(h,this.buf.length); this.buf=newBuf; this.i=0;}
  async nextByte(){ if(this.i>=this.buf.length) await this.refill(); return this.buf[this.i++]; }
  async nextFloat(){ const b0=await this.nextByte(),b1=await this.nextByte(),b2=await this.nextByte(),b3=await this.nextByte(); return (((b0<<24)|(b1<<16)|(b2<<8)|b3)>>>0)/4294967296; }
}

/* -----------------------------
   DOM & Game State
----------------------------- */
const serverSeedEl=document.getElementById('serverSeed');
const clientSeedEl=document.getElementById('clientSeed');
const nonceEl=document.getElementById('nonce');
const genBtn=document.getElementById('genSeedsBtn');
const startBtn=document.getElementById('startBtn');
const cashBtn=document.getElementById('cashBtn');
const stepDisplay=document.getElementById('stepDisplay');
const multDisplay=document.getElementById('multDisplay');
const lastOutcome=document.getElementById('lastOutcome');
const laneBtns=[document.getElementById('lane0'),document.getElementById('lane1'),document.getElementById('lane2')];
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');

let W=canvas.width,H=canvas.height; 
function resizeCanvas(){ W=canvas.clientWidth; H=W*0.5; canvas.height=H; draw(); }
window.addEventListener('resize',resizeCanvas); resizeCanvas();

let rng=null, obstacles=[], step=0, playing=false, chosenLane=null, pendingStep=false;
const stepFactor=0.22, obstacleProb=0.33;

/* -----------------------------
   Event Listeners
----------------------------- */
genBtn.onclick=()=>{ serverSeedEl.value=randHex(64); clientSeedEl.value=Math.random().toString(36).slice(2,12); nonceEl.value=Math.floor(Math.random()*999); updateHUD(); };
startBtn.onclick=startRound;
cashBtn.onclick=cashOut;
laneBtns.forEach((b,i)=>b.onclick=()=>{ if(pendingStep){ chosenLane=i; doStep(); }});
canvas.addEventListener('touchstart',e=>{ if(pendingStep){ const x=e.touches[0].clientX-canvas.getBoundingClientRect().left; chosenLane=Math.min(2,Math.floor(x/(W/3))); doStep(); }});
document.addEventListener('keydown',e=>{ if(pendingStep){ if(e.key==='ArrowLeft') chosenLane=Math.max(0,(chosenLane||1)-1); if(e.key==='ArrowRight') chosenLane=Math.min(2,(chosenLane||1)+1); doStep(); }});

/* -----------------------------
   Game Functions
----------------------------- */
async function startRound(){
  if(playing) return;
  const s=serverSeedEl.value.trim(), c=clientSeedEl.value.trim()||'demo', n=(nonceEl.value||'1').toString();
  rng=new DetermRNG(s,c,n); await rng.refill();
  obstacles=[];
  for(let i=1;i<=200;i++){ const f=await rng.nextFloat(); const lane=(f<obstacleProb)?(await rng.nextByte())%3:null; obstacles.push({step:i,lane}); }
  step=0; chosenLane=null; playing=true; pendingStep=true; lastOutcome.textContent='—';
  startBtn.disabled=true; cashBtn.disabled=false; draw(); updateHUD();
}

function cashOut(){ if(!playing) return; playing=false; pendingStep=false; startBtn.disabled=false; cashBtn.disabled=true; lastOutcome.textContent=`CASHED at step ${step} → ${(1+step*stepFactor).toFixed(2)}x`; updateHUD(); draw(); }

function doStep(){
  pendingStep=false; step++;
  const ob=obstacles[step-1]; let busted=false;
  if(ob.lane!==null && ob.lane===chosenLane){ busted=true; playing=false; lastOutcome.textContent=`BUST at step ${step}`; startBtn.disabled=false; cashBtn.disabled=true; }
  updateHUD(); draw(busted);
  if(playing) pendingStep=true; chosenLane=null;
}

function updateHUD(){
  stepDisplay.textContent=step;
  const mult=1+step*stepFactor;
  multDisplay.textContent=mult.toFixed(2)+'x';
}

function draw(bust=false){
  ctx.fillStyle='#041018'; ctx.fillRect(0,0,W,H);
  const lw=W/3;
  for(let i=0;i<3;i++){ ctx.fillStyle=(i%2===0)?'#061826':'#051720'; ctx.fillRect(i*lw,0,lw,H); }
  // obstacles
  const maxPreview=8;
  for(let ahead=0;ahead<maxPreview;ahead++){
    const s=step+ahead-1; if(s>=obstacles.length) continue; const ob=obstacles[s]; if(!ob||ob.lane===null) continue;
    const y=30 + ahead*(H-120)/maxPreview; const w=48-ahead*3;
    ctx.fillStyle=(ahead===0)?'#ff6b6b':'#7c3cff'; roundRect(ctx,ob.lane*lw+lw/2-w/2,y,w,16,6);
  }
  // runner
  const rx=(chosenLane!==null?chosenLane:1)*lw+lw/2, ry=H-56;
  ctx.fillStyle=bust?'#ff4b4b':'#28f0d0';
  roundRect(ctx,rx-26,ry-36,52,52,8);
  ctx.fillStyle='#041018'; ctx.font='700 18px sans-serif'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText((chosenLane!==null?chosenLane+1:1),rx,ry-12);
}

function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.fill(); }

draw();
</script>
</body>
</html>
